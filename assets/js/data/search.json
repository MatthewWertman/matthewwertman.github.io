[ { "title": "Create a Win10/11 KVM virtual machine with GPU passthrough", "url": "/posts/win-10-11-kvm-with-gpu-passthrough/", "categories": "writing, linux", "tags": "win10, qemu, kvm, libvirt, pcie, tutorial", "date": "2025-07-01 00:04:00 -0700", "snippet": "IntroductionIn this post, I will be giving detailed instructions on how to setup a Windows 10/11 KVM-based VM (Virtual Machine) with GPU passthrough.This guide includes how to setup your GPU with VFIO, creating the Win10 or Win11 Virtual machine within VMM (Virtual Machine Manager), configuring the VM for PCIe/GPU passthrough, and setting up the VM with the Looking Glass client.Why?This guide is for people wanting to achieve a high-performing local Windows VM on a Linux host without the need of dual-booting.Quick aside: Gaming on LinuxGaming on Linux has been a real pain point in the past. But withing the last few years, it has gotten way better with the help of Valve’s Proton compatability layer for Steam. However, even still, some games do require windows as the only way to play on PC. For example, online games that utilize Anti-Cheat software or DRM.This is the main reason I wanted a solution like this without the need to dual-boot or paying for a cloud provider subscription. Having something like this allows me to seemlessly switch between my Linux host and Windows guest and have very-comparable performance to running native Windows.This comes with a cost of it’s own, unfortually. This setup is quite lengthy and tedious and may have to adjust some steps to get it working for you. To get a setup like this working for my system took a lot of trail and error, but hopefully this guide can aid to avoiding some of the pitfalls that occur in this process.ResourcesHere is some further reading material that I have used to make this guide. Arch Wiki PCI passthrough via OVMF bryansteiner’s guide gpu-passthrough-tutorial Looking Glass DocsHardware Requirements Two GPUs (one guest GPU dedicated to the VM) CPU that supports hardware virtualization (Intel VT-x/VT-d or AMD-Vi) See the Arch Wiki for more detailed list of CPUs Motherboard that supports IOMMU Guest GPU ROM must support UEFI. Can find your GPU make/model here and verify Monitor with multiple inputs or multiple monitorsLooking Glass peripherals Secondary keyboard and mouse HMDI cable or optionally HDMI dummy adapterHardware SetupMy current configuration is as follows: CPU AMD Ryzen 7 5700X Motherboard MSI MPG B550 GPUs NVIDIA RTX 3070 (Guest Card) AMD Radeon RX 6800 (Host Card) RAM 64GB DDR4 (4x16) OS: Pop!_OS 22.04Kernel: 6.12.10-76061203-genericGetting startedFirstly, lets get some needed dependencies that we will need.sudo apt install libvirt-daemon-system libvirt-clients qemu-kvm qemu-utils qemu ovmf bridge-utils virt-manager virt-viewer libosinfo-bin -yAfter installing the packages, reboot your system into the BIOS to enable ‘VT-d’ or “Virtualization Technology” for Intel CPUs or ‘AMD-Vi’ for AMD if you haven’t already.To ensure that CPU virtualization is enabled:dmesg | grep VT-d # for Inteldmesg | grep AMD-Vi # for AMDSecondly verify that IOMMU is enabled:dmesg | grep -i IOMMUShould look something like this if enabled[ 0.000000] ACPI: DMAR 0x00000000BDCB1CB0 0000B8 (v01 INTEL BDW 00000001 INTL 00000001)[ 0.000000] Intel-IOMMU: enabled[ 0.028879] dmar: IOMMU 0: reg_base_addr fed90000 ver 1:0 cap c0000020660462 ecap f0101a[ 0.028883] dmar: IOMMU 1: reg_base_addr fed91000 ver 1:0 cap d2008c20660462 ecap f010da[ 0.028950] IOAPIC id 8 under DRHD base 0xfed91000 IOMMU 1[ 0.536212] DMAR: No ATSR found[ 0.536229] IOMMU 0 0xfed90000: using Queued invalidation[ 0.536230] IOMMU 1 0xfed91000: using Queued invalidation[ 0.536231] IOMMU: Setting RMRR:[ 0.536241] IOMMU: Setting identity map for device 0000:00:02.0 [0xbf000000 - 0xcf1fffff][ 0.537490] IOMMU: Setting identity map for device 0000:00:14.0 [0xbdea8000 - 0xbdeb6fff][ 0.537512] IOMMU: Setting identity map for device 0000:00:1a.0 [0xbdea8000 - 0xbdeb6fff][ 0.537530] IOMMU: Setting identity map for device 0000:00:1d.0 [0xbdea8000 - 0xbdeb6fff][ 0.537543] IOMMU: Prepare 0-16MiB unity mapping for LPC[ 0.537549] IOMMU: Setting identity map for device 0000:00:1f.0 [0x0 - 0xffffff][ 2.182790] [drm] DMAR active, disabling use of stolen memoryForce setting IOMMU in kernel parametersTo ensure that IOMMU is enabled everytime, you can set in your kernel parameters.For AMD users, this is not necessary as it is automatically enabled if your hardware supports it.In my case, I am using systemd as my boot loader:sudo kernelstub --add-optinos \"intel_iommu=on\" # for Intelsudo kernelstub --add-options \"amd_iommu=on\" # for AMDIf you are on GRUB, you can set it by editing /etc/default/grub:GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash intel_iommu=on\" # for IntelGRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash amd_iommu=on\" # for AMDFinding IOMMU GroupsAn IOMMU group is the smallest set of devices that can be passed into the VM. Meaning all devices within the group have to be passed into the VM.This can be a little bit tricky, but you want your Guest GPU that you are gonna pass in to be into its own isolated group.To see how your IOMMU groups are mapped out currently you can run the following bash script:#!/bin/bash##for d in /sys/kernel/iommu_groups/*/devices/*; do n=${d#*/iommu_groups/*}; n=${n%%/*} printf 'IOMMU Group %s ' \"$n\" lspci -nns \"${d##*/}\"doneExample output:IOMMU Group 15 04:00.0 PCI bridge [0604]: Advanced Micro Devices, Inc. [AMD/ATI] Navi 10 XL Upstream Port of PCI Express Switch [1002:1478] (rev c3)IOMMU Group 15 05:00.0 PCI bridge [0604]: Advanced Micro Devices, Inc. [AMD/ATI] Navi 10 XL Downstream Port of PCI Express Switch [1002:1479]IOMMU Group 15 06:00.0 VGA compatible controller [0300]: Advanced Micro Devices, Inc. [AMD/ATI] Navi 21 [Radeon RX 6800/6800 XT / 6900 XT] [1002:73bf] (rev c3)IOMMU Group 15 06:00.1 Audio device [0403]: Advanced Micro Devices, Inc. [AMD/ATI] Navi 21 HDMI Audio [Radeon RX 6800/6800 XT / 6900 XT] [1002:ab28]IOMMU Group 15 2a:00.0 Ethernet controller [0200]: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller [10ec:8168] (rev 15)IOMMU Group 16 2b:00.0 VGA compatible controller [0300]: NVIDIA Corporation GA104 [GeForce RTX 3070] [10de:2484] (rev a1)IOMMU Group 16 2b:00.1 Audio device [0403]: NVIDIA Corporation GA104 High Definition Audio Controller [10de:228b] (rev a1)If your Guest GPU isnt isolated in its own group. You will need to figure out a way to separate it out. If your Guest GPU is not in the top slot of your motherboard, you can try swapping it with your Host GPU. This may vary the grouping so that your Guest GPU is in it’s own group. If you have any other PCIe devices installed that are attached to that same slot of your Guest GPU (i.e an NVME drive). you can try moving that device to another slot. An alternative solution is ACS override patch. Can also check out this post by Alex Williamson. BEWARE as this comes with some risks.For my motherboard, I had to swap my GPUs around to get the Guest GPU into its own group.If you are able to isolate your GPU, like in the example above. You can continue to the next step!Binding VFIO drivers to the Guest GPUThere are many ways to achieve this. You can dynamically bind and unbind the VFIO drivers via libvirt hooks if you still want to utilize your Guest GPU when the VM is not running. See bryansteiner’s guide for an example setup.I havent had much luck with this however, but your mileage may vary. For this guide, I am simply going to disable/uninstall the nvidia drivers and early-load the VFIO drivers as my Guest GPU will be dedicated to the VM.Blacklisting Nvidia driverssudo bash -c \"echo blacklist nouveau &gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf\"sudo bash -c \"echo options nouveau modeset=0 &gt;&gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf\"Uninstalling the Nvidia driversAgain, this setup is not necessary. But, in my case, I have no need for them.sudo apt-get remove --purge '^nvidia-.*'Binding the VFIO driversTo bind the guest GPU to the VFIO drivers, you will need the PCI vendor ID for everything within the IOMMU group.lspci -nnExample output:05:00.0 PCI bridge [0604]: Advanced Micro Devices, Inc. [AMD/ATI] Navi 10 XL Downstream Port of PCI Express Switch [1002:1479]06:00.0 VGA compatible controller [0300]: Advanced Micro Devices, Inc. [AMD/ATI] Navi 21 [Radeon RX 6800/6800 XT / 6900 XT] [1002:73bf] (rev c3)06:00.1 Audio device [0403]: Advanced Micro Devices, Inc. [AMD/ATI] Navi 21 HDMI Audio [Radeon RX 6800/6800 XT / 6900 XT] [1002:ab28]2a:00.0 Ethernet controller [0200]: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller [10ec:8168] (rev 15)2b:00.0 VGA compatible controller [0300]: NVIDIA Corporation GA104 [GeForce RTX 3070] [10de:2484] (rev a1)2b:00.1 Audio device [0403]: NVIDIA Corporation GA104 High Definition Audio Controller [10de:228b] (rev a1)2c:00.0 Non-Essential Instrumentation [1300]: Advanced Micro Devices, Inc. [AMD] Starship/Matisse PCIe Dummy Function [1022:148a]2d:00.0 Non-Essential Instrumentation [1300]: Advanced Micro Devices, Inc. [AMD] Starship/Matisse Reserved SPP [1022:1485]2d:00.1 Encryption controller [1080]: Advanced Micro Devices, Inc. [AMD] Starship/Matisse Cryptographic Coprocessor PSPCPP [1022:1486]2d:00.3 USB controller [0c03]: Advanced Micro Devices, Inc. [AMD] Matisse USB 3.0 Host Controller [1022:149c]2d:00.4 Audio device [0403]: Advanced Micro Devices, Inc. [AMD] Starship/Matisse HD Audio Controller [1022:1487]My guest GPU is busid 2b:00.0 and 2b:00.1 which in the table above shows the vendor ids in the square brackets.So 10de:2484 and 10de:228bAfter you have the vendor IDs, you can set the kernel parameter to ensure that they bind after every boot:sudo kernelstub --add-option vfio-pci.ids=10de:2484,10de:228bFinally, reboot your system to start creating the VM!" }, { "title": "Using the $PIR Table to get PCIe device order", "url": "/posts/using-PIR-table-for-PCIe-device-order/", "categories": "writing, linux", "tags": "pcie, hiveos, mining, crypto, tutorial", "date": "2024-04-20 00:04:00 -0700", "snippet": "Identifying PCIe devices physically in a system can be a challenging problem. In my experience, when you have 6, 8, 12 PCIe devices in a system (GPUs in my case), they often don’t show up how you would expect. Now lets say one GPU starts having issues, how do you know which one is which?With the hardware that I have worked with, I have had a lot of success with using the $PIR table to identify which bus addresses are attached to which physical PCIe slot. In this blog, I will show you how you can do so with the help of a script!Introduction To The ProblemYou would think that if you had a series of 12 PCIe slots that they would show up in order (from left to right, starting closest to the CPU), but this is often not the case in my experience.In HiveOS specifically, they show the detected GPU devices in the system along with their assigned bus address after login:But not knowing the order of how the GPU devices were assigned makes it not feasible to hunt down a specific card by only its bus address. Leaving only the process of elimination to determine the problem card.The $PIR TableThe PCI Interrupt Routing Table ($PIR) is a table in read-only memory containing the routing information of the system’s PCI slot entries (embedded devices or physical PCIe slots). Each entry defines PCI device information that is attached to that slot, even an ‘slot number’ indicating the corresponding physical slot. So if we can figure out each PCIe slot’s corresponding slot number, we have all the information that we need to generate a “map” of the current rig!Getting StartedLet’s build this tool together and as we get further it should get a bit clearer of what is going on. Lets say we have 12 GPUs in a unit that is running HiveOS. As shown before, this is what we get when we log into the system:We can actually get this $PIR table data pretty easily within HiveOS with the following command:biosdecodeA lot of other BIOS information gets outputted as well but we are specifically after the PCI Interrupt Routing 1.0 present header. This is essentially the $PIR table printed in a human-readable formatThis section is mainly made up of slot entries which each represents PCI device. Each Slot Entry contains the device bus ID attached and slot number if available which acts like a designation for the physical slot. If we were to remove an GPU from the system and reboot, we would see that device ID and its corresponding table entry missing from the table. We can use these assigned slot numbers as identifiers to each physical slot on the motherboard and effectively made our map! Lets see what this looks like.Adding in GPUs one by one starting at the PCIe slot closest to the CPU will get us the slot number for each slot and identify which device is in which slot. Using this method, this is the order for our example: Physical Slot (starting at CPU) BIOS Slot Number Slot 1 16 Slot 2 37 Slot 3 38 Slot 4 39 Slot 5 40 Slot 6 41 Slot 7 42 Slot 8 43 Slot 9 48 Slot 10 53 Slot 11 54 Slot 12 55 Already we can put together our map of the GPU devices vs. their physical motherboard slots by replacing those slot numbers with the corresponding GPU bus IDs! Physical Slot (starting at CPU) GPU Bus ID Slot 1 01:00.0 Slot 2 07:00.0 Slot 3 08:00.0 Slot 4 09:00.0 Slot 5 0a:00.0 Slot 6 0b:00.0 Slot 7 0c:00.0 Slot 8 0d:00.0 Slot 9 02:00.0 Slot 10 03:00.0 Slot 11 04:00.0 Slot 12 05:00.0 Let’s write a script!Now that we have all of the needed information and know how to generate a GPU vs. PCIe slot map, we will automate it with a shell script:#!/bin/bash#### gpu_lookup_table -- generates a PCI bus address vs. PCIe slot map# $PIR found flagPIR=0# slot designations in order of left to right (starting at CPU)pir_map=(16 37 38 39 40 41 42 43 48 53 54 55)# store the output of biosdecodeC_BIOS_PIR_TABLE=\"$(sudo biosdecode)\"# not every system may have a $PIR table so we have a function to checkfunction check_for_pir_table { if echo \"$C_BIOS_PIR_TABLE\" | grep -q \"PCI Interrupt Routing\"; then return 0 fi return 1}# hiveos stores the detected GPU devices in json# parse $GPU_DETECT_JSON to get detected GPU bus addressesfunction get_gpu_info { [[ ! -f $GPU_DETECT_JSON ]] &amp;&amp; return 1 local gpu_detect_json=\"$(&lt; $GPU_DETECT_JSON)\" BUSID=() local idx=-1 while IFS=\";\" read busid brand vendor mem vbios name; do ((idx++)) BUSID[idx]=\"$busid\" done &lt; &lt;( echo \"$gpu_detect_json\" | jq -r -c '.[] | (.busid+\";\"+.brand+\";\"+.vendor+\";\"+.mem+\";\"+.vbios+\";\"+.name)' 2&gt;/dev/null ) [[ ${#BUSID[@]} -eq 0 ]] &amp;&amp; return 1 return 0}# get_pir_device_slot# $1 - GPU bus address# returns PCIe designation for given bus adddress in $PIRfunction get_pir_device_slot () { local C_GET_PIR_PCI_SLOT_NUMBER local pci_slot pci_slot=\"\" C_GET_PIR_PCI_SLOT_NUMBER=$(echo \"$C_BIOS_PIR_TABLE\" | grep \"$(echo \"$1\" | cut -d\".\" -f1)\" | grep -Poe 'slot number ([0-9]{1,})' | awk '{print $3}') if [[ -z $pci_slot ]]; then for (( idx=0; idx &lt; ${#pir_map[@]}; idx++ )); do if [[ \"${pir_map[$idx]}\" == \"$C_GET_PIR_PCI_SLOT_NUMBER\" ]]; then pci_slot=\"PCIE $((idx+1))\" break fi done fi echo \"$pci_slot\" unset C_GET_PIR_PCI_SLOT_NUMBER}if check_for_pir_table; then PIR=1 # $PIR was foundfiget_gpu_infoif [[ PIR -eq 1 ]]; then\tfor(( idx=1; idx &lt; ${#BUSID[@]}; idx++ )); do # idx starts at 1 to skip CPU busid dev=${BUSID[idx]} printf \"${BUSID[idx]} $(get_pir_device_slot $dev)\\n\" doneelse echo \"\\$PIR Table not found. Exitting...\"fiexit 0Running this script will get us the table we got previously:Adding support for AMD GPUsGenerally AMD GPUs detect in the system a little bit differently than Nvidia. Here is an example:When looking at one within lspci, there are multiple bus addresses to one card. The one we are after is the ‘VGA compatible controller’ (03:00.0 in this case).But when running the biosdecode command we see that the device IDs are actually the ‘Upstream Port of PCI Express Switch’ (01.00.0).To account for this we can add another function for AMD cards to get the proper bus address to search the $PIR with:# store lspci outputC_LSPCI_TABLE=\"$(lspci -mm)\"function get_amd_pir_busid () { local C_GET_AMD_BUSID local dev= if ! echo \"$C_LSPCI_TABLE\" | grep -q \"Ellesmere\"; then # Ellesmere behave like nvidia cards C_GET_AMD_BUSID=$(echo \"$C_LSPCI_TABLE\" | grep \"$1\" -B 2 | grep \"$1\" -B 2 | grep -Po '([0-9a-f]{2})(:00)\\.0' -m 1) dev=${C_GET_AMD_BUSID} else dev=$1 fi unset C_GET_AMD_BUSID echo \"$dev\"}This is the full script with AMD GPU support:#!/bin/bash#### gpu_lookup_table -- generates a PCI bus address vs. PCIe slot map; now with AMD support!# $PIR found flagPIR=0# slot designations in order of left to right (starting at CPU)pir_map=(16 37 38 39 40 41 42 43 48 53 54 55)# store the output of biosdecodeC_BIOS_PIR_TABLE=\"$(sudo biosdecode)\"# store lspci outputC_LSPCI_TABLE=\"$(lspci -mm)\"# not every system may have a $PIR table so we have a function to checkfunction check_for_pir_table { if echo \"$C_BIOS_PIR_TABLE\" | grep -q \"PCI Interrupt Routing\"; then return 0 fi return 1}# hiveos stores the detected GPU devices in json# parse $GPU_DETECT_JSON to get detected GPU bus addressesfunction get_gpu_info { [[ ! -f $GPU_DETECT_JSON ]] &amp;&amp; return 1 local gpu_detect_json=\"$(&lt; $GPU_DETECT_JSON)\" BUSID=() local idx=-1 while IFS=\";\" read busid brand vendor mem vbios name; do ((idx++)) BUSID[idx]=\"$busid\" BRAND[idx]=\"$brand\" done &lt; &lt;( echo \"$gpu_detect_json\" | jq -r -c '.[] | (.busid+\";\"+.brand+\";\"+.vendor+\";\"+.mem+\";\"+.vbios+\";\"+.name)' 2&gt;/dev/null ) [[ ${#BUSID[@]} -eq 0 ]] &amp;&amp; return 1 return 0}# get_pir_device_slot# $1 - GPU bus address# returns PCIe designation for given bus adddress in $PIRfunction get_pir_device_slot () { local C_GET_PIR_PCI_SLOT_NUMBER local pci_slot pci_slot=\"\" C_GET_PIR_PCI_SLOT_NUMBER=$(echo \"$C_BIOS_PIR_TABLE\" | grep \"$(echo \"$1\" | cut -d\".\" -f1)\" | grep -Poe 'slot number ([0-9]{1,})' | awk '{print $3}') if [[ -z $pci_slot ]]; then for (( idx=0; idx &lt; ${#pir_map[@]}; idx++ )); do if [[ \"${pir_map[$idx]}\" == \"$C_GET_PIR_PCI_SLOT_NUMBER\" ]]; then pci_slot=\"PCIE $((idx+1))\" break fi done fi echo \"$pci_slot\" unset C_GET_PIR_PCI_SLOT_NUMBER}function get_amd_pir_busid () { local C_GET_AMD_BUSID local dev= if ! echo \"$C_LSPCI_TABLE\" | grep -q \"Ellesmere\"; then # Ellesmere behave like nvidia cards C_GET_AMD_BUSID=$(echo \"$C_LSPCI_TABLE\" | grep \"$1\" -B 2 | grep \"$1\" -B 2 | grep -Po '([0-9a-f]{2})(:00)\\.0' -m 1) dev=${C_GET_AMD_BUSID} else dev=$1 fi unset C_GET_AMD_BUSID echo \"$dev\"}if check_for_pir_table; then PIR=1 # $PIR was foundfiget_gpu_infoif [[ PIR -eq 1 ]]; then\tfor(( idx=1; idx &lt; ${#BUSID[@]}; idx++ )); do # idx starts at 1 to skip CPU busid dev=${BUSID[idx]} if [[ \"${BRAND[idx]}\" == \"amd\" ]]; then dev=$(get_amd_pir_busid ${BUSID[idx]}) fi printf \"${BUSID[idx]} $(get_pir_device_slot $dev)\\n\" doneelse echo \"\\$PIR Table not found. Exitting...\"fiexit 0Extending the scriptEven though this script works for this system, its actually most likely not work with another. What we have done previously only works on systems with that same mapping/motherboard. If we wanted to add support for another motherboard, we would have to map it by adding GPU devices one by one and recording the attached slot numbers. Then its just a matter of adding that map to the above script. This is easier said than done, given there can be quirks when reading the $PIR table like this.It should be noted that the $PIR table contains data provided by the OEM/BIOS manufacturer. This makes it very dependent on the OEM to give accurate information. Information provided by the OEM may be incomplete, inaccurate, or wrong. This is why the data provided by the script can’t be 100% trusted. The goal of this script is to at least give a starting point when debugging rigs.ConclusionI mainly focused on HiveOS, but it should be possible to adapt to other Linux-based OSes (or even Windows) and other hardware. Obviously the main drawback with this approach is all the work necessary to ensure compatibility across systems, but what is front-facing to the user is a easy to understand table of how the GPU devices are mapped in the system for servicing!" }, { "title": "Momentum Mod - Getting Started", "url": "/posts/getting-started-momentum-mod/", "categories": "writing, game-dev", "tags": "momentum-mod, tutorial", "date": "2023-01-19 10:04:00 -0800", "snippet": "Momentum Mod is the hottest mod on the street right now, if you are into custom Source Engine game modes. This guide will go over the following: What is Momentum Mod? How do I install it? How do I setup and play?First Things First, What Is It?Momentum Mod is a standalone client for all your favorite Source game modes like Surf, Trick Surf, Bhop, Rocket Jumping, Climb, and more. While you can play all of these gamemodes on community servers, the ability to play them offline is great. Especically for modes like Surf, Bhop and Rocket Jumping and others where precision is key, reducing all latency is critical to ensure a smooth experience. Plus, having features like local replays, online leaderboard, zone editing tools, and custom HUD are really nice.Momentum Mod is still in active development. In fact, It has been effectively closed-source since 2021 due to the developers getting an official source engine license! Things have been a little quiet due to this but 1.0.0 is soon to be released and will mark the official public release of the mod, launching on platforms like Steam! The new engine behind Momentum Mod, Strata Source, is a modified branch of the Source Engine contributed by the people from Momentum Mod and Portal 2: Community Edition.InstallationWhile the mod is still not officially out, there is a way to get a version up and running locally on your system. Before going closed-source, the devs pushed out one last release of the existing codebase before going “dark” to hold people over until the 1.0 release. This is the version that this guide will show how to setup.Getting Momentum Mod 0.8.7The public evaluation build is available on their GitHub Releases: Momentum Mod v0.8.7There are few caveats with this build as detailed in the release to keep in mind of This does not work with our website. Runs will not submit or show up on our leaderboards. Map selection doesn’t work (and is even hidden in this build). Multiplayer (lobbies, SRCDS, etc) does not work. Download the .zip archive for your platform (Windows or Linux) and extract.To ensure everything was downloaded and extracted correctly, we will try and run the game.On WindowsDouble-click the run_momentum.bat file!On LinuxOpen a terminal in the extracted directory and run:chmod +x ./hl2.sh ./hl2_linux./hl2.sh -game momentumThe game should launch and show the main menu.Mounting CS:S and TF2 in Momentum ModA lot of surf/bhop/etc. maps depend on assets that are from Counter Strike: Source and Team Fortress 2, similar to the maps in Garry’s Mod (another Source game). If you don’t mount the required game assets, loading a map will likely result in a mess of missing textures and models. *img sourceTo “mount” the game assets, all we are doing is telling the game where these assets are located on the local system.I will show you how to point the game to the local assets of CS:S and TF2 on Windows and Linux. Make sure that both you own Counter Strike: Source and Team Fortress 2 and have them locally installed on your system.On WindowsAs indicated in the README.txt, adding the absolute(full) paths to the installed local files in momentum/gameinfo.txt should do the trick at least for Windows.game \"C:\\Program Files (x86)\\Steam\\steamapps\\common\\Counter-Strike Source\\cstrike\\cstrike_pak.vpk\"game \"C:\\Program Files (x86)\\Steam\\steamapps\\common\\Counter-Strike Source\\cstrike\\download\"game \"C:\\Program Files (x86)\\Steam\\steamapps\\common\\Counter-Strike Source\\cstrike\"game \"C:\\Program Files (x86)\\Steam\\steamapps\\common\\Team Fortress 2\\tf\\tf2_textures.vpk\"game \"C:\\Program Files (x86)\\Steam\\steamapps\\common\\Team Fortress 2\\tf\\tf2_misc.vpk\"game \"C:\\Program Files (x86)\\Steam\\steamapps\\common\\Team Fortress 2\\tf\\tf2_sound_misc.vpk\"game \"C:\\Program Files (x86)\\Steam\\steamapps\\common\\Team Fortress 2\\tf\\tf2_sound_vo_english.vpk\"game \"C:\\Program Files (x86)\\Steam\\steamapps\\common\\Team Fortress 2\\tf\\download\"Change the file paths to match where they are located on your local drive.On LinuxIf you try adding Linux paths in momentum/gameinfo.txt, it will not work as it only supports Windows paths. So we have to do some shenanigans (yay!).Earlier, when we lauched the game for the first time, it already made C:\\Program Files (x86)\\Steam/steamapps/... for us in the parent directory.However, the created cstrike and tf directories are empty so we will remove these and replace them with a symbolic link to our actual install location for each game, giving it access to the respective game assets.# CS:Srm -r C\\:/Program\\ Files\\ \\(x86\\)/Steam/steamapps/common/Counter-Strike\\ source/cstrikeln -s &lt;steam-install-location&gt;/Counter-Strike\\ Source/cstrike C\\:/Program\\ Files\\ \\(x86\\)/Steam/steamapps/common/Counter-Strike\\ source# TF2rm -r C\\:/Program\\ Files\\ \\(x86\\)/Steam/steamapps/common/Team\\ Fortress\\ 2/tfln -s &lt;steam-install-location&gt;/Team\\ Fortress\\ 2/tf C\\:/Program\\ Files\\ \\(x86\\)/Steam/steamapps/common/Team\\ Fortress\\ 2/Now, to ensure that it is properly mounted, we will launch the game again and type map cs_assualt in the console.This will load the Counter-Strike map ‘assault’. If mounting was successful, you should not see any missing textures or models and it will be all properly rendered!Adding More MapsSimply download your desired maps (.bsp) and place in momentum/maps and run map &lt;map_name&gt; in the console to play it!To get started, here is a collection of surf maps!Zoning and Closing NotesYou may have noticed that the timer doesn’t start when you start progressing through the map. Thats is because you have to setup zones on the map to configure when the timer should start and stop. This is where it gets out of depth of this guide. I might follow-up with another post all about zoning. In the meantime. you can check out this guide from the Momentum Mod folks! It should be able to get you started with basic zoning.This does mean you will have to do this for each map, but you only have to do it once. There are some repos out there that might already have zones ready to go like this one. Though I have found that these can be hit or miss. Specifically with surf maps, it is not too terrible since most maps are linear maps (only start and end)." }, { "title": "All About Little Martian!", "url": "/posts/little-martian/", "categories": "writing, game-dev", "tags": "little-martian, tutorial", "date": "2022-07-24 10:53:00 -0700", "snippet": "Brief introduction on how I found one of my favorite games to both play and develop!Origin StoryLittle Martian is a open world survival craft game (as of now, just a demo) created by Charlie, Jack, and Craig Smith. I think it’s a beautifully-crafted game and I sure have been having my fun with it. Not only have I been playing the game, but taking a deeper dive into the files to see what makes this game tick. Game development has always been a curiosity of mine. I have never fully developed a game before or even know where to begin.My plan was to essentially try and find a candidate that was easy to understand with my current limited knowledge of game-dev AND was able to be broken-down to it’s source files. Effectively, instead of building a game, reverse-engineering an existing one. At the time, I was also helping out on an open-source project centered around de-compiling/reverse-engineering a little known GameCube game called Gladius by Lucus Arts. A lot of it was over my head, so I didn’t work on the main tools, but rather creating helpful scripts/docs for people that were modding the game. At the root, this is where this idea came from. I wanted to work on my own project (something that I can actually understand!) on a little bit of a smaller scale.I ended up finding Little Martian, which was the perfect candidate for this! A simple 2D sprite-based game written in 100% JavaScript.Technologies Behind The GameConstruct3 is a HTML5 2D game engine aimed towards non and beginner programmers. Construct3 offers a lot of cool features like easy-to-use web editor, 3D-like capabilities, and cross-platform support for any device. Since it is all made with web technologies (HTML, CSS, and JS), these games built within the engine can be play on anything that can run a browser.NW.js/node-webkit is the main tool that helps make this cross-platform feature possible. Similar to Electron, you can write or turn your web applications to native standalone applications using chromium and nodejs. This is was Construct3 uses behind the scenes to bundle/distribute your game!How Does Contruct3/NW.js Pack Your Game?On the NW.js docs, it details two ways that it can package your app files: Plain Files - Put all your files in the same directory as the NW.js binaries Zip File - Package your app files into a zip file named ‘package.nw’ The second method can be seen in Little Martian. Looking in the root directory, you will see an ‘package.nw’ like mentioned in the docs. I have not personally used Construct3 and am not sure if this is something that the developer can control or if it just the default settings set in the engine.Accessing The Game Files WARNING: The following section showcases how to get access to the source files of Little Martian and therefore can ruin the experience of the game. Even though it is only a demo, some spoilers may be exposed.With the history out of the way, I want to get into how exactly I got access to the source files for the game. It was surprising easy! You can even follow along with this section and start exploring the files yourself.Firstly, however, I do recommend playing the game first as this might ruin the game for you.Lets start by getting the game! Simply go the Little Martian’s website and download for your current platform. At the time of this post, the game is not fully out yet and only offers a playable demo right now. The current version is 0.6.2.If you are reading in the future and the above version is not the current version any longer, don’t worry! The following content should work no matter what version. Just download what ever the latest version is. Or maybe the game is finally out on Steam. Depending on the platform, the following directory tree may look quite a bit different. Linux and Windows have a pretty similar structure. Mac OS’s content mainly takes place in Contents/Resources/.As you will see, I will be working with the linux build.After you extract the zip archive, you will see a new directory little-martian-0.6.2-&lt;your-platform&gt;.The following is the structure of the Linux version of the game.└── little-martian-0.6.2-linux ├── icudtl.dat ├── lib │   ├── libEGL.so │   ├── libffmpeg.so │   ├── libGLESv2.so │   ├── libnode.so │   └── libnw.so ├── little-martian ├── locales │   ├── en-US.pak │   └── en-US.pak.info ├── nacl_helper ├── nacl_helper_bootstrap ├── nw_100_percent.pak ├── nw_200_percent.pak ├── package.nw ├── resources.pak ├── swiftshader │   ├── libEGL.so │   └── libGLESv2.so └── v8_context_snapshot.binThere is another directory, __MACOSX, but this can be safely ignored/deleted.The key file to be aware of is the package.nw archive or Contents/Resources/app.nw on Mac OS as this is where all of the game files are stored! In here is all the engine code (!) and user scripts for the game.And it is just as simple as extracting the package.nw archive as any other zip archive!Here is the inner package.nw project structure:├── cursor.css├── data.json├── icons│ ├── ...├── images│ ├── ...├── index.html├── media│ ├── ...├── package.json├── scripts│ ├── c3runtime.js│ ├── dispatchworker.js│ ├── jobworker.js│ ├── main.js│ └── supportcheck.js├── style.cssGame Extractor ScriptAs a bonus, I will include a helpful shell script that does just this.#!/bin/bash# game_extractor -- extracts little-martian game# get unzip and perlunzip=\"$(which unzip)\"perl=\"$(which perl) -pe\"os=\"linux\"version=\"0.6.2\"package=\"package.nw\"function format_version_number (){ v=\"$1\" length=${#1} if [[ length -eq 2 ]]; then v=\"0$1\" fi if [[ length -eq 1 ]]; then v=\"00$1\" fi echo $v | $perl 's/(\\d)(?=\\d)/\\1\\./g'}function safe_cd (){ cd \"$1\" || { echo \"$0: Error: unable to change directory to $1\" &gt;&amp;2; exit 1; }}OPTIND=1while getopts \":o:v:a\" opt; do case \"$opt\" in \"o\") os=$OPTARG; ;; \"v\") version=$(format_version_number \"$OPTARG\"); ;; \\? ) echo \"$0: Error: Invalid Parameter -$OPTARG.\"; print_usage; exit 1 ;; : ) echo \"$0: Error: $OPTARG requires an agrument.\" &gt;&amp;2; exit 1 ;; esacdoneshift $(($OPTIND - 1))location=\"little-martian-${version}-${os}/\"$unzip little-martian-${version}-${os}.zip -d $locationrm -rf \"$location/__MACOSX\"if [[ $os == \"mac\" ]]; then location=\"little-martian-${version}-${os}/Little Martian (${version}).app/Contents/Resources/\" package=\"app.nw\"else location=\"little-martian-${version}-${os}/little-martian-${version}-${os}/\"fisafe_cd \"$location\"$unzip $packageexit 0To use, run the following: ./game_extractor -o &lt;platform&gt; -v &lt;game-version&gt;Closing NotesFeel free to try on your own! You are now able to explore and even get into modifying the files.Something to play with is this randomizer script that I wrote in Python. It will randomize the starting itemsthat you get from your ship! Make sure to have the game extracted before running the randomizer.One last thing, I really want to thank the devs for their amazing game! I am excited to see the finished product and have become a fan of their work. I have interacted with Craig, the lead developer, and he was really nice and was telling me of some cool ideas that might get added! Tune into their Twitter or Discord server for updates with the links below. Show them some love!LinksLittle Martian websiteLittle Martian TwitterLittle Martian Discord Invite" }, { "title": "First Post!", "url": "/posts/first-post/", "categories": "writing, meta, first", "tags": "hello-world", "date": "2022-07-21 15:18:00 -0700", "snippet": "This is my first post!I have had this idea for a while now and I am very excited to actually do it! If you havent already, be sure to check out the About tab. In short, I wanted to start writing about my learnings and personal projects that I am working on. Hopefully I can provide some insight on what I am learning and my thought process. Maybe can even help someone else having a similar problem/idea.I jump around a lot when it comes to projects, and my projects span over many different areas. Which I think works well of a blog-like environemnt like this!Some topics that I expect to cover heavily: Linux Shell-scripting Game/Mod Development Software/Tools Node Self-Hosting/Homelab serverBut of course, Thats not all! I plan to cover basically whatever I am currently learning, developing, or thinking about.Anyway, That’s it for now.See you soon. :)" } ]
